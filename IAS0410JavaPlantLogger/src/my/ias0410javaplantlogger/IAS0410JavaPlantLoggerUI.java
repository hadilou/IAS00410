/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package my.ias0410javaplantlogger;

import java.awt.Color;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.StringWriter;
import java.net.InetAddress;
import java.net.Socket;
import java.net.UnknownHostException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.text.DecimalFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Timer;
import java.util.TimerTask;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.JTextPane;
import javax.swing.filechooser.FileNameExtensionFilter;
import javax.swing.text.BadLocationException;
import javax.swing.text.DefaultCaret;
import static javax.swing.text.DefaultCaret.ALWAYS_UPDATE;
import javax.swing.text.Style;
import javax.swing.text.StyleConstants;
import javax.swing.text.StyledDocument;
import jdk.incubator.jpackage.internal.IOUtils;

/**
 *
 * @author Toshiba
 */
public class IAS0410JavaPlantLoggerUI extends javax.swing.JFrame {

    /**
     * Creates new form IAS0410JavaPlantLoggerUI
     */
    public IAS0410JavaPlantLoggerUI() {
        initComponents();
        
        closeButton.setEnabled(false);
        connectButton.setEnabled(false);
        disconnectButton.setEnabled(false);
        startButton.setEnabled(false);
        breakButton.setEnabled(false);
        
        addColoredText
            (logbookText, 
             "Open log file to start.\n", 
             Color.BLACK);
        
        timer3s = new Timer();
        task = new TimerTask()
            {
                @Override
                public void run() 
                {
                }
            };
        timerDeclared = true; 
        emptyTask = true;
        
        socketCreated = false;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        logbookPanel = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        logbookText = new javax.swing.JTextPane();
        logfilePanel = new javax.swing.JPanel();
        openButton = new javax.swing.JButton();
        closeButton = new javax.swing.JButton();
        connectionPanel = new javax.swing.JPanel();
        disconnectButton = new javax.swing.JButton();
        connectButton = new javax.swing.JButton();
        measurementPanel = new javax.swing.JPanel();
        startButton = new javax.swing.JButton();
        breakButton = new javax.swing.JButton();
        exitButton = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setMinimumSize(new java.awt.Dimension(389, 500));
        setPreferredSize(new java.awt.Dimension(389, 500));

        logbookPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Log Book"));

        logbookText.setCursor(new java.awt.Cursor(java.awt.Cursor.TEXT_CURSOR));
        jScrollPane1.setViewportView(logbookText);

        javax.swing.GroupLayout logbookPanelLayout = new javax.swing.GroupLayout(logbookPanel);
        logbookPanel.setLayout(logbookPanelLayout);
        logbookPanelLayout.setHorizontalGroup(
            logbookPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.Alignment.TRAILING)
        );
        logbookPanelLayout.setVerticalGroup(
            logbookPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 175, Short.MAX_VALUE)
        );

        logfilePanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Log File"));
        logfilePanel.setPreferredSize(new java.awt.Dimension(389, 80));

        openButton.setText("Open");
        openButton.setMaximumSize(new java.awt.Dimension(90, 25));
        openButton.setMinimumSize(new java.awt.Dimension(90, 25));
        openButton.setName("openButton"); // NOI18N
        openButton.setPreferredSize(new java.awt.Dimension(90, 25));
        openButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                openButtonActionPerformed(evt);
            }
        });

        closeButton.setText("Close");
        closeButton.setMaximumSize(new java.awt.Dimension(90, 25));
        closeButton.setMinimumSize(new java.awt.Dimension(90, 25));
        closeButton.setPreferredSize(new java.awt.Dimension(90, 25));
        closeButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                closeButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout logfilePanelLayout = new javax.swing.GroupLayout(logfilePanel);
        logfilePanel.setLayout(logfilePanelLayout);
        logfilePanelLayout.setHorizontalGroup(
            logfilePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(logfilePanelLayout.createSequentialGroup()
                .addContainerGap(62, Short.MAX_VALUE)
                .addComponent(openButton, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 73, Short.MAX_VALUE)
                .addComponent(closeButton, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(62, Short.MAX_VALUE))
        );
        logfilePanelLayout.setVerticalGroup(
            logfilePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(logfilePanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(logfilePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.CENTER)
                    .addComponent(openButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(closeButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap())
        );

        connectionPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Connection"));
        connectionPanel.setPreferredSize(new java.awt.Dimension(389, 80));

        disconnectButton.setText("Disconnect");
        disconnectButton.setMaximumSize(new java.awt.Dimension(90, 25));
        disconnectButton.setMinimumSize(new java.awt.Dimension(90, 25));
        disconnectButton.setPreferredSize(new java.awt.Dimension(90, 25));
        disconnectButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                disconnectButtonActionPerformed(evt);
            }
        });

        connectButton.setText("Connect");
        connectButton.setMaximumSize(new java.awt.Dimension(90, 25));
        connectButton.setMinimumSize(new java.awt.Dimension(90, 25));
        connectButton.setPreferredSize(new java.awt.Dimension(90, 25));
        connectButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                connectButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout connectionPanelLayout = new javax.swing.GroupLayout(connectionPanel);
        connectionPanel.setLayout(connectionPanelLayout);
        connectionPanelLayout.setHorizontalGroup(
            connectionPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, connectionPanelLayout.createSequentialGroup()
                .addContainerGap(62, Short.MAX_VALUE)
                .addComponent(connectButton, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 73, Short.MAX_VALUE)
                .addComponent(disconnectButton, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(62, Short.MAX_VALUE))
        );

        connectionPanelLayout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {connectButton, disconnectButton});

        connectionPanelLayout.setVerticalGroup(
            connectionPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(connectionPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(connectionPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.CENTER)
                    .addComponent(connectButton, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(disconnectButton, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap())
        );

        measurementPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Measurement"));
        measurementPanel.setPreferredSize(new java.awt.Dimension(389, 80));

        startButton.setText("Start");
        startButton.setMaximumSize(new java.awt.Dimension(90, 25));
        startButton.setMinimumSize(new java.awt.Dimension(90, 25));
        startButton.setPreferredSize(new java.awt.Dimension(90, 25));
        startButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                startButtonActionPerformed(evt);
            }
        });

        breakButton.setText("Break");
        breakButton.setMaximumSize(new java.awt.Dimension(90, 25));
        breakButton.setMinimumSize(new java.awt.Dimension(90, 25));
        breakButton.setPreferredSize(new java.awt.Dimension(90, 25));
        breakButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                breakButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout measurementPanelLayout = new javax.swing.GroupLayout(measurementPanel);
        measurementPanel.setLayout(measurementPanelLayout);
        measurementPanelLayout.setHorizontalGroup(
            measurementPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, measurementPanelLayout.createSequentialGroup()
                .addContainerGap(62, Short.MAX_VALUE)
                .addComponent(startButton, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 73, Short.MAX_VALUE)
                .addComponent(breakButton, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(62, Short.MAX_VALUE))
        );

        measurementPanelLayout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {breakButton, startButton});

        measurementPanelLayout.setVerticalGroup(
            measurementPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(measurementPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(measurementPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(startButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(breakButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap())
        );

        exitButton.setText("Exit");
        exitButton.setMaximumSize(new java.awt.Dimension(90, 25));
        exitButton.setMinimumSize(new java.awt.Dimension(90, 25));
        exitButton.setPreferredSize(new java.awt.Dimension(90, 25));
        exitButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                exitButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap(150, Short.MAX_VALUE)
                .addComponent(exitButton, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 149, Short.MAX_VALUE))
            .addComponent(logbookPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addComponent(measurementPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addComponent(logfilePanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addComponent(connectionPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(logbookPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(logfilePanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(connectionPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(measurementPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(exitButton, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(11, 11, 11))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void openButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_openButtonActionPerformed
        // TODO add your handling code here:
        JFileChooser chooser = new JFileChooser();
        chooser.addChoosableFileFilter(chooser.getAcceptAllFileFilter());
        chooser.addChoosableFileFilter
            (new FileNameExtensionFilter("Text files", "txt"));
        chooser.addChoosableFileFilter
            (new FileNameExtensionFilter("C++ Source Codes", "cpp"));
        int returnVal = chooser.showOpenDialog(getParent());
        if(returnVal == JFileChooser.APPROVE_OPTION) 
        {
            file = chooser.getSelectedFile();
            
            if(file.exists()) 
            {                  
                addColoredText(logbookText, "File opened.\n", Color.BLACK);
                openButton.setEnabled(false);
                closeButton.setEnabled(true);
                connectButton.setEnabled(true);
            }    
            else
            {
                addColoredText
                    (logbookText, "File does not exist!\n", Color.RED);
            }
        }
        else
        {
            addColoredText
                (logbookText, 
                 "Cannot open file! JFileChooser not approved!\n", 
                 Color.RED);
        }
    }//GEN-LAST:event_openButtonActionPerformed

    private void exitButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_exitButtonActionPerformed
        try 
        {
            // TODO add your handling code here:
            if(socketCreated)
            {
                if(!sock.isClosed())
                {
                    sock.close();
                }
                socketCreated = false;
            }
            
            file = null;
            System.exit(0);
        } 
        catch (IOException ex) 
        {
            addColoredText
                (logbookText, "Cannot close the socket!\n", Color.RED);
        }      
    }//GEN-LAST:event_exitButtonActionPerformed

    private void startButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_startButtonActionPerformed
        // TODO add your handling code here:
        closeButton.setEnabled(false);
        startButton.setEnabled(false);
        breakButton.setEnabled(true);
        
        addColoredText(logbookText, "Sending Start command...\n", Color.BLACK);
        
        // Send Start command
        final int startBufferSize = 16;
        byte[] startBuffer = new byte[startBufferSize];
        final char[] startWChar = "Start".toCharArray();
        // Write the 4-byte data size into the send buffer
        for (int i = 0; i < 4; i++)
        {
            startBuffer[3 - i] = (byte)(startBufferSize >> (i * 8));
        }
        startBuffer[0] = startBuffer[3];
        startBuffer[3] = 0x00;
        
        // Write the data to be sent into the send buffer
        for (int i = 0; i < 5; i++)
        {
            startBuffer[2 * i + 4] = (byte)startWChar[i];
            startBuffer[2 * i + 5] = 0x00;
        }
        
        // Add 2-byte 0
        startBuffer[14] = 0;
        startBuffer[15] = 0;
        
        try 
        {
            outStream.write(startBuffer, 0, startBufferSize);
            outStream.flush();
            addColoredText
                (logbookText, "Waiting for response....\n", Color.BLACK);
            
            final int readyBufferSize = 4096;
            byte[] readyBuffer = new byte[readyBufferSize];
            int bytesReceived;
            bytesReceived = inStream.read(readyBuffer, 0, readyBufferSize);
            if (bytesReceived > 0)
            {
                char[] message = new char[4096];
                for (int i = 0; i < bytesReceived; i++)
                {
                    message[i] = (char)readyBuffer[i + 4];
                }
                String timeStamp = new SimpleDateFormat("dd/MM/yyyy-HH:mm:ss").format(Calendar.getInstance().getTime());

                // Print the server response
                addColoredText
                    (logbookText, 
                     ("Measurement results at"+timeStamp+":\n"), 
                     Color.BLACK);
                            
                os = new FileOutputStream(file);

                os.write
                    (("Measurement results at"+timeStamp+":\r\n").getBytes(),
                     0, 
                     ("Measurement results at"+timeStamp+":\r\n").length());
                
                int channelNumber = 
                    (message[3] << 24) + 
                    (message[2] << 16) + 
                    (message[1] << 8) + 
                    (message[0]);
                int ptNumber;
                int channelCount = 0;
                int ptCount = 0;
                int bytePtr = 4;
                String point;
                byte[] number;
                number = new byte[8];
                double dNumber;
                int iNumber;
                
                while (channelCount < channelNumber)
                {
                    ptNumber = 
                        (message[bytePtr + 3] << 24) + 
                        (message[bytePtr + 2] << 16) + 
                        (message[bytePtr + 1] << 8) + 
                        (message[bytePtr]);
                    bytePtr += 4;

                    String channelName = "";
                    // Write channel name
                    while (message[bytePtr] != '\0')
                    {
                        channelName += message[bytePtr];
                        bytePtr++;
                    }
                    addColoredText
                        (logbookText, channelName + ":\n", Color.BLACK);
                    
                    os.write
                        ((channelName + ":\r\n").getBytes(),
                         0, 
                         (channelName + ":\r\n").length());
                    bytePtr++;
                    
                    // Write points in this channel
                    while (ptCount < ptNumber)
                    {
                        point = "";
                        // Write point name
                        while (message[bytePtr] != '\0')
                        {
                            point += message[bytePtr];
                            bytePtr++;
                        }
                        
                        addColoredText
                            (logbookText, point + ": ", Color.BLACK);

                        os.write
                            ((point + ": ").getBytes(),
                             0, 
                             (point + ": ").length());
                        bytePtr++;
                        
                        // Write the number
                        if ( 
                             point.toLowerCase().contains("level") 
                            )
                        {
                            iNumber = 
                                (message[bytePtr + 3] << 24) + 
                                (message[bytePtr + 2] << 16) + 
                                (message[bytePtr + 1] << 8) + 
                                (message[bytePtr]);
                            
                            addColoredText
                                (logbookText, 
                                        
                                 Integer.toString(iNumber), 
                                 Color.BLACK);

                            os.write
                                (Integer.toString(iNumber).getBytes(),
                                 0, 
                                 Integer.toString(iNumber).length());
                            bytePtr += 4;
                        }
                        else
                        {
                            for (int i = 0; i < 8; i++)
                            {
                                number[i] = readyBuffer[bytePtr + 4];
                                bytePtr++;
                            }

                            dNumber = ByteBuffer.
                                wrap(number).
                                order(ByteOrder.LITTLE_ENDIAN).
                                getDouble();
                            String tmpStr ;
                            if (point.toLowerCase().contains("flow")) {
                                tmpStr = new DecimalFormat("##.###").format(dNumber);
                            }
                            else {
                                tmpStr = new DecimalFormat("##.#").format(dNumber);
                            }
                            addColoredText
                                (logbookText, 
                                 tmpStr, 
                                 Color.BLACK);

                            os.write
                                (tmpStr.getBytes(),
                                 0, 
                                 tmpStr.length());
                        }
                        
                        // Write the unit
                        if ((point.contains("flow")))
                        {
                            addColoredText
                                (logbookText, 
                                 " m³/s\n", 
                                 Color.BLACK);

                            os.write
                                (" m³/s\r\n".getBytes(),
                                 0, 
                                 " m³/s\r\n".length());
                        }
                        else if (
                                 point.toLowerCase().contains("temperature"))
                        {
                            addColoredText
                                (logbookText, 
                                 " °C\n", 
                                 Color.BLACK);

                            os.write
                                (" °C\r\n".getBytes(),
                                 0, 
                                 " °C\r\n".length());
                        }
                        else if (
                                 (point.contains("pressure")))
                        {
                            addColoredText
                                (logbookText, 
                                 " atm\n", 
                                 Color.BLACK);

                            os.write
                                (" atm\r\n".getBytes(),
                                 0, 
                                 " atm\r\n".length());
                        }
                        else if (
                                  point.toLowerCase().contains("Level") 
                                 )
                        {
                            addColoredText
                                (logbookText, 
                                 "%\n", 
                                 Color.BLACK);

                            os.write
                                ("%\r\n".getBytes(),
                                 0, 
                                 "%\r\n".length());
                        }
                        
                        ptCount++;
                    }
                    
                    ptCount = 0;
                    channelCount++;
                }
                
                addColoredText
                    (logbookText, 
                     "\n\n", 
                     Color.BLACK);

                os.write
                    ("\r\n".getBytes(),
                     0, 
                     "\r\n".length());
                
                if((!timerDeclared) || emptyTask)
                {
                    timer3s = new Timer();
                    timerDeclared = true;
                    task = new TimerTask() 
                    {
                        @Override
                        public void run() 
                        {
                            sendReady();
                        }
                    };
                    emptyTask = false;
                    timer3s.scheduleAtFixedRate(task, 0, 3000);
                }           
            }
            else
            {
                addColoredText
                    (logbookText, 
                     "Data cannot be retrieved from the server!\n", 
                     Color.RED);
            }
        } 
        catch (IOException ex) 
        {
            addColoredText
                (logbookText, "Cannot send Start command!\n", Color.RED);
        }
    }//GEN-LAST:event_startButtonActionPerformed

    private void closeButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_closeButtonActionPerformed
        // TODO add your handling code here:
        if(connectButton.isEnabled())
        {
            file = null;
            openButton.setEnabled(true);
            closeButton.setEnabled(false);
            connectButton.setEnabled(false);
            disconnectButton.setEnabled(false);
            startButton.setEnabled(false);
            breakButton.setEnabled(false);
            addColoredText(logbookText, "File closed.\n", Color.BLACK);
            addColoredText
                (logbookText, 
                 "Click Open to select a file, Exit to close the application.\n", 
                 Color.BLACK);
        }
        else
        {
            JOptionPane.showMessageDialog(this, "Close the connection first!");
        }
    }//GEN-LAST:event_closeButtonActionPerformed

    private void connectButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_connectButtonActionPerformed
        // TODO add your handling code here:
        connectButton.setEnabled(false);
        
        try 
        { 
            hostAddress = InetAddress.getByAddress(new byte[] {127,0,0,1});
            try 
            {
                sock = new Socket(hostAddress, port);
                socketCreated = true;
                try 
                {
                    inStream = sock.getInputStream();
                    outStream = sock.getOutputStream();
                    final int bufferIDSize = 4096;
                    byte[] bufferID = new byte[bufferIDSize];

                    addColoredText
                        (logbookText, 
                         "Waiting for ID request...\n", 
                         Color.BLACK);

                    disconnectButton.setEnabled(true);
                    startButton.setEnabled(true);

                    // Receive Identify message
                    int bytesReceivedID;
                    bytesReceivedID = inStream.read(bufferID, 0, bufferIDSize);
                    if (bytesReceivedID > 0)
                    {
                        String messageID = "";
                        for (int i = 0; i < (bufferID[0] - 6)/2; i++)
                        {
                            messageID += (char)bufferID[2 * i + 4];
                        }

                        addColoredText
                            (logbookText, 
                             "Server responded: " + messageID + "\n", 
                             Color.BLACK);

                        if (messageID.equals("Identify"))
                        {
                            addColoredText
                                (logbookText, 
                                 "Sending password...\n", 
                                 Color.BLACK);

                            // Send password: coursework
                            final int size = 26;
                            byte[] pwBuffer = new byte[size];
                            final char[] pwWChar = "coursework".toCharArray();
                            // Write the 4-byte data size into the send buffer
                            for (int i = 0; i < 4; i++)
                            {
                                pwBuffer[3 - i] = (byte)(size >> (i * 8));
                            }
                            pwBuffer[0] = pwBuffer[3];
                            pwBuffer[3] = 0x00;

                            // Write the data to be sent into the send buffer
                            for (int i = 0; i < 10; i++)
                            {
                                pwBuffer[2 * i + 4] = (byte)pwWChar[i];
                                pwBuffer[2 * i + 5] = 0x00;
                            }

                            // Add 2-byte 0
                            pwBuffer[24] = 0;
                            pwBuffer[25] = 0;

                            outStream.write(pwBuffer, 0, size);
                            outStream.flush();

                            // Receive Accepted message
                            final int bufferAccSize = 4096;
                            byte[] bufferAcc = new byte[bufferAccSize];

                            addColoredText
                                (logbookText, 
                                "Password sent. Waiting for accept...\n", 
                                Color.BLACK);

                            int bytesReceivedAcc = inStream.read
                                (bufferAcc, 0, bufferAccSize);
                            if (bytesReceivedAcc > 0)
                            {
                                String messageAcc = "";
                                for (int i = 0; i < (bufferAcc[0] - 6)/2; i++)
                                {
                                    messageAcc += (char)bufferAcc[2 * i + 4];
                                }

                                addColoredText
                                    (logbookText, 
                                     "Server responded: " + messageAcc + "\n", 
                                     Color.BLACK);
                            }
                            else
                            {
                                addColoredText
                                    (logbookText, 
                                     "Data cannot be retrieved from the server!\n", 
                                     Color.RED);}
                            }
                        else
                        {
                            addColoredText
                                (logbookText, 
                                 "ID request was not obtained from the server!", 
                                 Color.RED);
                        }
                    }
                }
                catch (IOException ioe) 
                {
                    addColoredText
                        (logbookText, "Cannot bind data streams!\n", Color.RED);
                }  
            }
            catch (IOException ex2) 
            {
                addColoredText
                    (logbookText, "Cannot create socket!\n", Color.RED);
            }
        }
        catch (UnknownHostException ex1) 
        {
            addColoredText
                (logbookText, "Cannot get host address!\n", Color.RED);
        }
    }//GEN-LAST:event_connectButtonActionPerformed

    private void disconnectButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_disconnectButtonActionPerformed
        // TODO add your handling code here:
        connectButton.setEnabled(true);
        closeButton.setEnabled(true);
        disconnectButton.setEnabled(false);
        startButton.setEnabled(false);
        breakButton.setEnabled(false);
        
        if(timerDeclared)
        {
            timer3s.cancel();
            task.cancel();
            timerDeclared = false;
        }
    
        addColoredText(logbookText, "Sending Stop command...\n", Color.BLACK);
        
        // Send Stop command
        final int stopSize = 14;
        byte[] stopBuffer = new byte[stopSize];
        final char[] stopWChar = "Stop".toCharArray();
        // Write the 4-byte data size into the send buffer
        for (int i = 0; i < 4; i++)
        {
            stopBuffer[3 - i] = (byte)(stopSize >> (i * 8));
        }
        stopBuffer[0] = stopBuffer[3];
        stopBuffer[3] = 0x00;

        // Write the data to be sent into the send buffer
        for (int i = 0; i < 4; i++)
        {
            stopBuffer[2 * i + 4] = (byte)stopWChar[i];
            stopBuffer[2 * i + 5] = 0x00;
        }

        // Add 2-byte 0
        stopBuffer[12] = 0;
        stopBuffer[13] = 0;

        try 
        {
            outStream.write(stopBuffer, 0, stopSize);
            outStream.flush();
            addColoredText(logbookText, "Disconnected.\n", Color.BLACK);            
            sock.close();
            socketCreated = false;
        } 
        catch (IOException ex) 
        {
            addColoredText
                (logbookText, "Cannot send Stop command!\n", Color.RED);
        }   
    }//GEN-LAST:event_disconnectButtonActionPerformed

    private void breakButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_breakButtonActionPerformed
        // TODO add your handling code here:
        closeButton.setEnabled(true);
        startButton.setEnabled(true);
        breakButton.setEnabled(false);
        
        if(timerDeclared)
        {
            timer3s.cancel();
            task.cancel();
            timerDeclared = false;
        }
        
        addColoredText(logbookText, "Sending Break command...\n", Color.BLACK);
        
        // Send Break command
        final int breakBufferSize = 16;
        byte[] breakBuffer = new byte[breakBufferSize];
        final char[] breakWChar = "Break".toCharArray();
        // Write the 4-byte data size into the send buffer
        for (int i = 0; i < 4; i++)
        {
            breakBuffer[3 - i] = (byte)(breakBufferSize >> (i * 8));
        }
        breakBuffer[0] = breakBuffer[3];
        breakBuffer[3] = 0x00;
        
        // Write the data to be sent into the send buffer
        for (int i = 0; i < 5; i++)
        {
            breakBuffer[2 * i + 4] = (byte)breakWChar[i];
            breakBuffer[2 * i + 5] = 0x00;
        }
        
        // Add 2-byte 0
        breakBuffer[14] = 0;
        breakBuffer[15] = 0;
        
        try 
        {
            outStream.write(breakBuffer, 0, breakBufferSize);
            outStream.flush();
            
            addColoredText
                (logbookText, "Downloading is stopped.\n", Color.BLACK);
        } 
        catch (IOException ex) 
        {
            addColoredText
                (logbookText, "Cannot send Break command!\n", Color.RED);
        }
    }//GEN-LAST:event_breakButtonActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try 
        {
            for (javax.swing.UIManager.LookAndFeelInfo info : 
                    javax.swing.UIManager.getInstalledLookAndFeels()) 
            {
                if ("Nimbus".equals(info.getName())) 
                {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } 
        catch (ClassNotFoundException | 
               InstantiationException | 
               IllegalAccessException | 
                javax.swing.UnsupportedLookAndFeelException ex) 
        {
            java.util.logging.Logger.getLogger
                (IAS0410JavaPlantLoggerUI.class.getName()).log(java.util.logging.Level.SEVERE, 
                 null, 
                 ex);
        }
        //</editor-fold>
        
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(() -> 
        {
            new IAS0410JavaPlantLoggerUI().setVisible(true);
        });
    }
    
    private void addColoredText(JTextPane pane, String text, Color color) 
    {
        StyledDocument doc = pane.getStyledDocument();

        Style style = pane.addStyle("Color Style", null);
        StyleConstants.setForeground(style, color);
        try 
        {         
            doc.insertString(doc.getLength(), text, style);
            DefaultCaret caret = (DefaultCaret) pane.getCaret();
            caret.setUpdatePolicy(ALWAYS_UPDATE);
        } 
        catch (BadLocationException ex) 
        {
            Logger.getLogger
                (IAS0410JavaPlantLoggerUI.class.getName()).log(Level.SEVERE,
                 null,
                 ex);
        }
    }
    
    private void sendReady() 
    {
        addColoredText(logbookText, "Sending Ready command...\n", Color.BLACK);
        
        // Send Ready command
        final int readyBufferSize = 16;
        byte[] readyBuffer = new byte[readyBufferSize];
        final char[] readyWChar = "Ready".toCharArray();
        // Write the 4-byte data size into the send buffer
        for (int i = 0; i < 4; i++)
        {
            readyBuffer[3 - i] = (byte)(readyBufferSize >> (i * 8));
        }
        readyBuffer[0] = readyBuffer[3];
        readyBuffer[3] = 0x00;
        
        // Write the data to be sent into the send buffer
        for (int i = 0; i < 5; i++)
        {
            readyBuffer[2 * i + 4] = (byte)readyWChar[i];
            readyBuffer[2 * i + 5] = 0x00;
        }
        
        // Add 2-byte 0
        readyBuffer[14] = 0;
        readyBuffer[15] = 0;
        
        try 
        {
            outStream.write(readyBuffer, 0, readyBufferSize);
            outStream.flush();
            receiveReady();
        } 
        catch (IOException ex) 
        {
            addColoredText
                (logbookText, "Cannot send Ready command!\n", Color.RED);
        }
    }
    
    private void receiveReady() 
    {
        addColoredText
            (logbookText, "Waiting for response....\n", Color.BLACK);

        final int readyBufferSize = 4096;
        byte[] readyBuffer = new byte[readyBufferSize];
        int bytesReceived;
        try {
            bytesReceived = inStream.read(readyBuffer, 0, readyBufferSize);
            if (bytesReceived > 0)
            {
                char[] message = new char[4096];
                for (int i = 0; i < bytesReceived; i++)
                {
                    message[i] = (char)readyBuffer[i + 4];
                }

                // Print the server response
               String timeStamp = new SimpleDateFormat("dd/MM/yyyy-HH:mm:ss").format(Calendar.getInstance().getTime());

                addColoredText
                    (logbookText, 
                     ("Measurement results at "+timeStamp+":\n"), 
                     Color.BLACK);

                os.write
                    (("Measurement results at"+timeStamp+":\r\n").getBytes(),
                     0, 
                     ("Measurement results at"+timeStamp+":\r\n").length());

                int channelNumber = 
                    (message[3] << 24) + 
                    (message[2] << 16) + 
                    (message[1] << 8) + 
                    (message[0]);
                int ptNumber;
                int channelCount = 0;
                int ptCount = 0;
                int bytePtr = 4;
                String point;
                byte[] number;
                number = new byte[8];
                double dNumber;
                int iNumber;

                while (channelCount < channelNumber)
                {
                    ptNumber = 
                        (message[bytePtr + 3] << 24) + 
                        (message[bytePtr + 2] << 16) + 
                        (message[bytePtr + 1] << 8) + 
                        (message[bytePtr]);
                    bytePtr += 4;

                    String channelName = "";
                    // Write channel name
                    while (message[bytePtr] != '\0')
                    {
                        channelName += message[bytePtr];
                        bytePtr++;
                    }
                    addColoredText
                        (logbookText, channelName + ":\n", Color.BLACK);

                    os.write
                        ((channelName + ":\r\n").getBytes(),
                         0, 
                         (channelName + ":\r\n").length());
                    bytePtr++;

                    // Write points in this channel
                    while (ptCount < ptNumber)
                    {
                        point = "";
                        // Write point name
                        while (message[bytePtr] != '\0')
                        {
                            point += message[bytePtr];
                            bytePtr++;
                        }

                        addColoredText
                            (logbookText, point + ": ", Color.BLACK);

                        os.write
                            ((point + ": ").getBytes(),
                             0, 
                             (point + ": ").length());
                        bytePtr++;

                        // Write the number
                        if (
                             point.contains("Level"))
                        {
                            iNumber = 
                                (message[bytePtr + 3] << 24) + 
                                (message[bytePtr + 2] << 16) + 
                                (message[bytePtr + 1] << 8) + 
                                (message[bytePtr]);
                            
                            addColoredText
                                (logbookText, 
                                 (new DecimalFormat("##").format(iNumber)), 
                                 Color.BLACK);

                            os.write
                                ((new DecimalFormat("##").format(iNumber)).getBytes(),
                                 0, 
                                 Integer.toString(iNumber).length());
                            bytePtr += 4;
                        }
                        else
                        {
                            for (int i = 0; i < 8; i++)
                            {
                                number[i] = readyBuffer[bytePtr + 4];
                                bytePtr++;
                            }
                            
                            dNumber = ByteBuffer.
                                wrap(number).
                                order(ByteOrder.LITTLE_ENDIAN).
                                getDouble();
                            String tmpStr;
                            if (point.toLowerCase().contains("flow")) {
                                tmpStr = new DecimalFormat("##.###").format(dNumber);
                            }
                            else {
                                tmpStr = new DecimalFormat("##.#").format(dNumber);
                            }
                            addColoredText
                                (logbookText, 
                                 tmpStr, 
                                 Color.BLACK);

                            os.write
                                (tmpStr.getBytes(),
                                 0, 
                                 tmpStr.length());
                        }

                        // Write the unit
                        if ((point.contains("flow")))
                        {
                            addColoredText
                                (logbookText, 
                                 " m³/s\n", 
                                 Color.BLACK);

                            os.write
                                (" m³/s\r\n".getBytes(),
                                 0, 
                                 " m³/s\r\n".length());
                        }
                        else if ( 
                                 point.toLowerCase().contains("temperature"))
                        {
                            addColoredText
                                (logbookText, 
                                 " °C\n", 
                                 Color.BLACK);
                            
                            os.write
                                (" °C\r\n".getBytes(),
                                 0, 
                                 " °C\r\n".length());
                        }
                        else if (
                                 (point.contains("pressure")))
                        {
                            addColoredText
                                (logbookText, 
                                 " atm\n", 
                                 Color.BLACK);

                            os.write
                                (" atm\r\n".getBytes(),
                                 0, 
                                 " atm\r\n".length());
                        }
                        else if (
                                  point.toLowerCase().contains("level")
                                 )
                        {
                            addColoredText
                                (logbookText, 
                                 "%\n", 
                                 Color.BLACK);

                            os.write
                                ("%\r\n".getBytes(),
                                 0, 
                                 "%\r\n".length());
                        }
                     

                        ptCount++;
                    }

                    ptCount = 0;
                    channelCount++;
                }

                addColoredText
                    (logbookText, 
                     "\n\n", 
                     Color.BLACK);

                os.write
                    ("\r\n".getBytes(),
                     0, 
                     "\r\n".length());
            }
            else
            {
                addColoredText
                    (logbookText, 
                     "Data cannot be retrieved from the server!\n", 
                     Color.RED);
            }
        } 
        catch (IOException ex) 
        {
            addColoredText
                (logbookText, 
                 "Data cannot be retrieved from the server!\n", 
                 Color.RED);
        }
    }
    
    private Timer timer3s;
    private boolean timerDeclared;
    private TimerTask task; 
    private boolean emptyTask;
    private File file;
    private InetAddress hostAddress; 
    private Socket sock;
    private boolean socketCreated;
    private final int port = 1234;
    private InputStream inStream;
    private OutputStream outStream;
    private OutputStream os;

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton breakButton;
    private javax.swing.JButton closeButton;
    private javax.swing.JButton connectButton;
    private javax.swing.JPanel connectionPanel;
    private javax.swing.JButton disconnectButton;
    private javax.swing.JButton exitButton;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JPanel logbookPanel;
    private javax.swing.JTextPane logbookText;
    private javax.swing.JPanel logfilePanel;
    private javax.swing.JPanel measurementPanel;
    private javax.swing.JButton openButton;
    private javax.swing.JButton startButton;
    // End of variables declaration//GEN-END:variables
}
